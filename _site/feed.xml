<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>front-end.su</title>
    <description>front-end разработка в деталях</description>
    <link>http://front-end.su/</link>
    <atom:link href="http://front-end.su/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Function composition</title>
        <description>&lt;p&gt;Йо камрады =)
Прошлый раз я показал как можно создавать функции первого класса, а в этой заметке я покажу как их можно круто пользовать.&lt;/p&gt;

&lt;p&gt;Есть вот такие вот умные определения:
&amp;gt;«Композиция» — (от лат. compositio — составление — связывание) объединение, составление, сопоставление, расположение, сложение, соединение частей в единое целое в определенном порядке.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;В математике композиция функций (суперпози́ция фу́нкций) — это применение одной функции к результату другой.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;На деле вы постоянно встречали подобный прием:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const x1 = 1;
const x2 = add(x1, 1);
const x3 = add(x1, 2);
const x4 = add(x1, 3);
const result = x4;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Для того чтобы не создавать лишних констант или переменных, мы можем сделать сосиску вызовов функций =)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const result = add(3, add(2, add(1, 1)));
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;На мой взгляд выглядит лучше, ибо места занимает меньше, никаких лишних переменных не придумали, но чем больше действий надо сделать над входными данными, тем длиннее эта сосиска становится, поддерживать такой код станет труднее, разбираться в нем никто не захочет, в отличии от 1 примера где каждый шаг четко прослеживается.&lt;/p&gt;

&lt;p&gt;В функциональных языках есть функции помощники, они берут на себя заботу о лишней вложенности нашей функции, и как работяги на стройке передают один кирпичик другому рабочему.
Разберем функцию &lt;code class=&quot;highlighter-rouge&quot;&gt;pipe&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;compose&lt;/code&gt; из моей любимой рамды конечно же =)
Перепишем пример выше:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const result = pipe(
    add(1), // 1 =&amp;gt; n =&amp;gt; 1 + n;
    add(2), // 2 =&amp;gt; n =&amp;gt; 2 + n;
    add(3), // 3 =&amp;gt; n =&amp;gt; 3 + n;
)
result(1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Не трудно догадаться что делает функция с название труба =) она как водопроводная труба передает данные из начала в конец, добавляя наши примеси где нужно.
Вы же помните нашу каррированую функцию &lt;code class=&quot;highlighter-rouge&quot;&gt;add = x =&amp;gt; y =&amp;gt; x + y&lt;/code&gt;? мы частично вызвали функцию добавления, и все что осталось нам, передать в нее последний аргумент, чтобы она завелась.
Вот так вот схематически выглядит функция pipe:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
function pipe (f,g,j) {
  return function(x) {
    return j(g(f(x)));
  };
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;0 ноль магии, всю заботу о нечеловекочитаемой сосиске взяла на себя она.
с функцией add то все понятно, она меленькая, простая, тупая. тут не интересно, нужно больше практики,
Вчера я добавил в своего бота для телеграм возможность рандомного выбора темплейта для сообщения, и вот как я это сделал&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const STRINGS = [
  `Тут *|name|* \nРешил заказать песню *|track|*`,
  `Ну зачем ты *|name|* \nпросишь эту фигню? *|track|*`,
  `Вадик, тут твой друган *|name|* \nопять фигню просит *|track|*`,
  `Вова, ты знаешь этого чела? *|name|* \nон пестню хочет *|track|*`,
  `Я *|name|* \nжелаю поплясать под *|track|*`
];

const randomTpl = arr =&amp;gt; arr[Math.floor(Math.random() * arr.length)];

const stringTpl = ({ name, track }) =&amp;gt; pipe(
    randomTpl, // передаем массив строк, и выбираем 1 случайную
    replace(&quot;|track|&quot;, track), // функция реплейс из рамды, принимает 3 аргумента: шаблон, строка на которую менять, и ПОСЛЕДНИМ аргументом строку в которой менять
    replace(&quot;|name|&quot;, name), // все функции тут возвращают НОВОЕ значение, и никак не мутируют старое
)(STRINGS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Теперь этот бот умеет ругаться по разному, и почти в функциональном стиле =)&lt;/p&gt;

&lt;p&gt;Давайте еще пример, украл задачу с кодварс, нужна функция проверяющая является ли слово палиндромом
&amp;gt;Слово или фраза, которые одинаково читаются слева направо и справа налево.&lt;/p&gt;

&lt;p&gt;Решений в интернете полно, но мы ща очень лаконично напишем свое:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const isPalindrom = str =&amp;gt; {
    // сначала нужно развернуть строку
    const reverseString = pipe(
        split(&#39;&#39;), // конвертируем строку в массив
        reverse, // разворачиваем массив
        join(&#39;&#39;) // склеиваем обратно
    );
    return str === reverseString(str);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Лучшей читаемости я наверно не видал в жизни, каждый шаг это чистая функция которая делает всего 1 вещь, и передает свой результат дальше.
Представьте как круто то, что вы можете на создавать таких промежуточных функций, и так же склеивать их в 1 с помощью &lt;code class=&quot;highlighter-rouge&quot;&gt;pipe&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;compose&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;Про &lt;code class=&quot;highlighter-rouge&quot;&gt;compose&lt;/code&gt;: Делает она тоже самое что и &lt;code class=&quot;highlighter-rouge&quot;&gt;pipe&lt;/code&gt; только функции вызываются справа налево, то есть в обратном порядке.
у нас в команде, мы пришли к мнению, что pipe читается легче.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
compose(
    C,
    B,
    A,
)(&#39;kek&#39;);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Итак лонгрид опять получился, на неделе покидаю интересных примеров, а может быть и задачек маленьких =))
Следующий раз покажу как можно использовать оч крутую функцию &lt;code class=&quot;highlighter-rouge&quot;&gt;evolve&lt;/code&gt; из рамды&lt;/p&gt;

</description>
        <pubDate>Wed, 16 Aug 2017 00:00:00 +0400</pubDate>
        <link>http://front-end.su/jekyll/pixyll/2017/08/16/function-composition/</link>
        <guid isPermaLink="true">http://front-end.su/jekyll/pixyll/2017/08/16/function-composition/</guid>
      </item>
    
      <item>
        <title>First class functions</title>
        <description>&lt;p&gt;Дарова котаны, настала пора очередной порции умных штучек.
Хочу поведать вам о частичном применении функции, чо эт и как им пользоваться.&lt;/p&gt;

&lt;p&gt;Для начала хочу познакомить вас с умным словом &lt;code class=&quot;highlighter-rouge&quot;&gt;функции первого класса&lt;/code&gt;
Вот выписка из вики: 
&lt;em&gt;В информатике язык программирования имеет функции первого класса, если он рассматривает функции как объекты первого класса. В частности, это означает, что язык поддерживает передачу функций в качестве аргументов другим функциям, возврат их как результат других функций, присваивание их переменным или сохранение в структурах данных&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Давайте сразу к делу, возьмем самый сахарный пример, который естественно вы никогда не встретите в продакшене(а я вот встретил);&lt;/p&gt;

&lt;p&gt;представьте простую функцию которая складывает 2 числа, назовем ее add:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const add = (a, b) =&amp;gt; a + b;
add(0, 1) // 1;
add(10, 1) // 11;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;на этом ее область применения заканчивается, функция полностью справляется со своими задачами, но давайте вколим немного стероидов в этого малыша.
Как мы читканули с вики, функция может возвращать не только результат вычисления но и функцию, перепишем add:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const add = a =&amp;gt; b =&amp;gt; a + b;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Функция add принимает 1 аргумент и возвращает функцию, которая принимает еще 1 аргумент и делает вычисление:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
add(0)(1) // 1;
add(10)(1) // 11;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Редаксоюзеры уже узнали подобное написание? &lt;code class=&quot;highlighter-rouge&quot;&gt;connect(mapStateToProps)(MyComponent)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Пока нихрена удобного, найдем применение:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const inc = add(1);
inc(2) // 3;
inc(5) // 6;
inc(inc(0)) // 2;

const dec = add(-1);
dec(1) // 0;
dec(dec(2)) // 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;мы не стали создавать новые однотипные функции, просто использовали базовую.
Преобразование add(a,b) в add(a)(b) называется каррирование;
Каждый раз вызывать функцию add с двумя скобками удручающе, поэтому в некоторых вспомогательных библиотеках(таких как рамда) есть понятие достаточно количество аргументов: если функция получила не достаточно аргументов то она вернет функцию ожидающее остаточные:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
add(1, 2) === add(1)(2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Подобный подход удобен когда вы создаете композиции функций, ну или вот живой пример:
у менять есть функция которая проверяет длину строки, и возвращает тру или фолс:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
  const lessThan = (a, b) =&amp;gt; a &amp;lt; b;
  const noLongerThan = n =&amp;gt; s =&amp;gt; lessThan(length(s), n);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;и я передаю функцию валидации очень просто:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const validate = noLongerThan(100);
const validate2 = noLongerThan(1000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;вот у меня есть 2 функции которые ожидают на вход строку и возвращают тру или фолс =)
Еще я перелопачивал один объект в другой руками, например:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const A = { a:1 , b: { c: 3 }  };
const B = { a: b.c };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Это была интеграция платежки, и получаемый объект от магазина был абсолютно не похож на тот который должен был улететь в платежную систему, писать каждый раз key: a.b.c.d || null было не очень то и прикольно, на помощь пришли функции первого класса:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
// функция pathOr получает на вход дефолтное значение, массив пути, и сам объект
const getFromPayloadByPath = p =&amp;gt; pathOr(null, p.split(&#39;.&#39;), payloadObject);

const sendingObject = {
    a: getFromPayloadByPath(&#39;c.b&#39;),
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;таких сосисок у меня было оч много, только представьте сколько инфы нужно отправить в платежную систему =)
Не стоит боятся того, что функция может вернуть другую функцию, стоит один раз попробовать, и вы в это влюбитесь так же как и я, это поначалу кажется странным и запутанным, но стоит преодолеть свой страх и открывается чудный мир из бесконечных возможностей.
Следующий высер обещаю написать про композицию функций справа налево и слева направо, где буду применять функции первого класса.&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Aug 2017 00:00:00 +0400</pubDate>
        <link>http://front-end.su/jekyll/pixyll/2017/08/16/first-class-functions/</link>
        <guid isPermaLink="true">http://front-end.su/jekyll/pixyll/2017/08/16/first-class-functions/</guid>
      </item>
    
      <item>
        <title>Evolve</title>
        <description>&lt;p&gt;Всем привет, в программировании на js часто приходится изменять содержимое объекта, добавляя, удаляя, изменяя поля, самый простой способ это конечно же присваивание:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
obj.counter = obj.counter + 1
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Проблема тут в том, что мы мутируем исходный объект, а это никак не допустимо в рамках функционального программирования, да и вне его, например в редьюсере &lt;code class=&quot;highlighter-rouge&quot;&gt;redux&lt;/code&gt; вы не увидите изменений если мутировали стейт.
Нужно возвращать каждый раз новый объект, например с помощью спрэд оператора &lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt; в &lt;code class=&quot;highlighter-rouge&quot;&gt;ES6&lt;/code&gt; (деструктурирующее присваивание если быть точнее):&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const newObject = {
  ...obj,
  counter: obj.counter + 1,
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Но с высокой вложенностью начинает происходить страшный ад на экране, с огромным каскадом и обилием трех точек =)
Так же в популярных либах есть хелперы в виде &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; функции, например из &lt;code class=&quot;highlighter-rouge&quot;&gt;lodash&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
_.merge({}, obj, { counter: obj.counter + 1 })
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Это работает очень просто, склеивает объекты слева на право, заменяя дублирующие ключи.
Благо у нас уже есть возможность использовать нейтив инструмент из коробки: &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.assign()&lt;/code&gt;, делает тоже самое
&amp;gt; Метод Object.assign() используется для копирования значений всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект. После копирования он возвращает целевой объект.&lt;/p&gt;

&lt;p&gt;Писателям на реакте знакома подобная конструкция:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
this.setState({ counter: this.state.counter + 1 })
// или 
this.setState({ show: !this.state.show })
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;В целом ок, но если не нужно передать какую то вложенность объекта:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
this.setState(s =&amp;gt; ({ 
  ...s, 
  deep: {
   counter: s.deep.counter + 1,
   show: !s.deep.show,
  }
}))
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;На мой взгляд начинает выглядеть громоздко,
В либе &lt;code class=&quot;highlighter-rouge&quot;&gt;ramda&lt;/code&gt; есть отличная функция &lt;code class=&quot;highlighter-rouge&quot;&gt;evolve&lt;/code&gt;,
Она принимает на вход 2 объекта и возвращает всегда новый;
Ее сигнатура выглядит так: &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;k:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(v&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;→&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;v)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;→&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;k:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;→&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;k:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
в человеческом языке так: &lt;code class=&quot;highlighter-rouge&quot;&gt;evolve(объектМутатор, исходныйОбъект)&lt;/code&gt;
Вот как она работает:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const inc = n =&amp;gt; n + 1;
const newObj = evolve({ counter: inc }, obj)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;что произошло? 1 аргументом мы передали объект, с теми ключами, значения которых мы хотим поменять, но вместо значений, мы передали наши функции первого класса, они же в свою очередь получат аргументом, значение из начального объекта(&lt;code class=&quot;highlighter-rouge&quot;&gt;исходныйОбъект&lt;/code&gt;);
Создадим еще примеров,&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const add = a =&amp;gt; b =&amp;gt; a + b; // это мы помним
const inc = add(1) // это тоже
const dec = add(-1) 

const not = b =&amp;gt; !b; // Функция меняющая булево значение на противоположное
// not(true) = false
// not(false) = true


const state = {
    counter: 0,
    show: false,
}

const stateTransformer = {
    counter: inc,
    show: not,
}

const newState = evolve(stateTransformer, state);
// newState { counter: 1,  show: true }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Функция &lt;code class=&quot;highlighter-rouge&quot;&gt;evolve&lt;/code&gt; каррированая, а это значит что можно использовать ее так: &lt;code class=&quot;highlighter-rouge&quot;&gt;evolve(объектМутатор)(исходныйОбъект)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Для меня в реакте это означает что я могу сделать что то в этом духе:&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
this.setState(evolve(stateTransformer));
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Давайте больше примеров:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
const T = () =&amp;gt; true; // функция возвращает true
const F = () =&amp;gt; false; // функция возвращает false
const transformDecrease = { counter: dec  };
const transformincrease = { counter: inc  };

const transformToggleShow = { show: not  };
const transformShow = { show: T };
const transformHide = { show: F };


const handleButtonInc = () =&amp;gt; {
    this.state(evolve(transformincrease))
}

const handleButtonDec = () =&amp;gt; {
    this.state(evolve(transformDecrease))
}

const showCounter = () =&amp;gt; {
    this.setState(evolve(transformShow))
}
// можно комбинировать трансформеры, как обычные объекты
const showAdnInc = () =&amp;gt; {
    this.setState(merge(transformShow, transformincrease));
}

// или передавать в композицию:

const x = pipe(
    evolve(transformShow),
    evolve(transformincrease),
)
this.setState(x);
// тоже самое, что :
this.setState(evolve(transformincrease, evolve(transformShow)))

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;evolve&lt;/code&gt; это лишь один из способов изменить объект, простой, удобный, и красивый, опять же, по моему мнению =)&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Aug 2017 00:00:00 +0400</pubDate>
        <link>http://front-end.su/jekyll/pixyll/2017/08/16/evolve/</link>
        <guid isPermaLink="true">http://front-end.su/jekyll/pixyll/2017/08/16/evolve/</guid>
      </item>
    
      <item>
        <title>Заметка: Первое впечатление о reselect для redux</title>
        <description>&lt;p&gt;Всем привет, меня зовут &lt;a href=&quot;https://twitter.com/pvpshoot&quot;&gt;Миша&lt;/a&gt;, и автор этого блога сподвиг меня написать сюда заметку, которой я поделился в нашем фронтенд чатике слака.
Речь пойдет о библиотеке &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt; для &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;Redux&lt;/a&gt;.
Если вы уже используете в работе recompose то смело закрывайте статью, и читайте новости поинтереснее этой.
Всех остальных призываю к прочтению&lt;/p&gt;

&lt;p&gt;Итак если вы наверняка часто видели подобную конструкицию в ваших компонентах и она успела приесться:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const mapStateToProps = state =&amp;gt; ({
    couponsList: state.couponsReducer.couponsList,
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Все что я сделал, это передал массив купонов из редакс стора в пропсы коспонента.
Раньше я ограничивался подобным, и всю логику по дальнейшиму разруливанию я делал внутри компонента.
В этом кейсе мне нужно было отфильтровать только валидные купоны, и посчитать общуюю сумму дискаунта.&lt;/p&gt;

&lt;p&gt;Товарищ по работе намекнул на реселект, и я решил попробовать.
Итак я преступил к работе, для начала я вынес получение массива куппонов в отдельную функцию&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const couponsSelector = state =&amp;gt; state.couponsReducer.couponsList
const mapStateToProps = state =&amp;gt; ({
    couponsList: couponsSelector(state),
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Пока изменений мало но мысль заложена хорошая, у нас есть чистая функция, которая получает стейт идостает из него наш массив.
Эту функцию мы можем вынести в отдельный файл, в папочке selectors рядом с нашим редьюсерами и импортить их в любом нужном нам компоненте.
Но соглаитесь, пока все это оверхед&lt;/p&gt;

&lt;p&gt;Итак продолжаем, обратимся к reselect для фильтрации только валидных куппонов:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const couponsSelector = state =&amp;gt; state.couponsReducer.couponsList
const validCouponsListSelector = createSelector(
    couponsSelector,
    arr =&amp;gt; validateCoupons(arr),
)
const mapStateToProps = state =&amp;gt; ({
    couponsList: couponsSelector(state),
    validCouponsList: validCouponsListSelector(state),
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Опа, что это мы сейчас сделали?
А мы добавили новый селектор, который в качесве 1 аргумента получает другой селектор, а последним функцию обработчик.
Вот пример из док:
    const taxSelector = createSelector(
        subtotalSelector,
        taxPercentSelector,
        (subtotal, taxPercent) =&amp;gt; subtotal * (taxPercent / 100)
    )&lt;/p&gt;

&lt;p&gt;Сечете? мы передали в функцию &lt;code class=&quot;highlighter-rouge&quot;&gt;createSelector&lt;/code&gt; два наших селектора, а вконце получили их значение в функции обработчике&lt;/p&gt;

&lt;p&gt;Итак уже есть пару селекторов для моего компонента, но нужно больше, мне нужно получить полную скидку, вперед:
    const totalDiscountSelector = createSelector(
        validCouponsListSelector,
        coupons =&amp;gt; calculateSumm(coupons),
    )
    const mapStateToProps = state =&amp;gt; ({
        couponsList: couponsSelector(state),
        validCouponsList: validCouponsListSelector(state),
        totalDiscount: totalDiscountSelector(state),
    })&lt;/p&gt;

&lt;p&gt;Нам не пришлось сохранять промежуточное значение &lt;code class=&quot;highlighter-rouge&quot;&gt;validCouponsList&lt;/code&gt; для дальнейшего использования, а ведь и оно тоже нам пригодится
Этих селекторов может быть куча, так я расширил свое приложение следующим образом:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const limitedDiscountSelector = createSelector(
    totalDiscountSelector,
    discountTypeSelector,
    discountLimiter,
    (total, discType, limiter) =&amp;gt; pleaseLimitMydiscount(total, discType, limiter)
);
const mapStateToProps = state =&amp;gt; ({
    couponsList: couponsSelector(state),
    validCouponsList: validCouponsListSelector(state),
    discountType: discountTypeSelector(state),
    discountLimiter: discountLimiterSelector(state),
    totalDiscount: totalDiscountSelector(state),
    limitedDiscount: limitedDiscountSelector(state), 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Пользователь может захотеть задать максимальную допустимую скидку для купонов, а они ведь могут быть разных видов, одни процентные скидки, другие денежные. 
По дефлоту реселект позволяет кешировать данные, и делет их проверку внутри себя, но вы вольны сделать свою собственную мемоизацию.
Я вынес все селеторы в отельный модуль, для удобного хранения и доступа из других компонентов.
Освободил компонент от лишнего кода, что облегчело понимание что же он должен делать, а не как.
Спасибо за чтение.
Рекомендую рекомпоз к ознакомлениею и дальнейшему использованию!
Пишите мне в &lt;a href=&quot;https://twitter.com/pvpshoot&quot;&gt;twitter&lt;/a&gt; если хотите подискутировать на эту тему&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Mar 2017 00:00:00 +0400</pubDate>
        <link>http://front-end.su/zametka-pervoe-vpechatlenie-o-recompose-dlya-redux-html</link>
        <guid isPermaLink="true">http://front-end.su/zametka-pervoe-vpechatlenie-o-recompose-dlya-redux-html</guid>
      </item>
    
      <item>
        <title>Создание Alix, Chrome-расширения для линтинга HTML</title>
        <description>&lt;p&gt;&lt;i&gt;Данный материал является вольным переводом статьи: &lt;br /&gt;Ire Aderinokun &lt;a href=&quot;https://bitsofco.de/making-alix-a-chrome-extension-for-linting-html/&quot;&gt;Making Alix, a Chrome Extension for Linting HTML&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;На прошлой неделе я написала о том, как вы можете &lt;a href=&quot;https://bitsofco.de/linting-html-using-css/&quot;&gt;использовать CSS селекторы для линтинга HTML&lt;/a&gt;. Идея этой концепции заключалась в том, что мы можем использовать некоторые продвинутые селекторы, такие как &lt;code class=&quot;highlighter-rouge&quot;&gt;:not()&lt;/code&gt; чтобы выбрать определенные типы элементов на странице. Например, мы можем выбрать все изображения, у которых нет альтернативного текста, и применить к ним стиль, чтобы выделить их на странице.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img:not([alt]) {  
    border: 5px solid red;
}

/* Add an error message */
img:not([alt])::after {  
   content: &quot;Images must have an alt attribute&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;После написания этой статьи я обнаружила, что &lt;a href=&quot;http://heydonworks.com/revenge_css_bookmarklet/&quot;&gt;множество&lt;/a&gt; &lt;a href=&quot;http://disq.us/url?url=http://archive.oreilly.com/pub/a/network/2000/07/21/magazine/css_tool.html:q4ix0_OUH1ABT47phcu1age-5Tw&amp;amp;cuid=3490249&quot;&gt;других&lt;/a&gt; &lt;a href=&quot;https://disq.us/url?url=https://mathiasbynens.be/notes/css-hidden-elements:icJwuKHh3fzutZrF7QzsaC0z6Zg&amp;amp;cuid=3490249&quot;&gt;людей&lt;/a&gt; уже использовали эту идею. Лучшим решением среди найденных, оказался &lt;a href=&quot;http://ffoodd.github.io/a11y.css/&quot;&gt;a11y.css&lt;/a&gt; созданный &lt;a href=&quot;https://twitter.com/ffoodd_fr&quot;&gt; Gaël Poupard&lt;/a&gt;. Поэтому я решила воспользоваться его наработками.&lt;/p&gt;

&lt;p&gt;Чтобы всем было удобно пользоваться я решила сделать расширение для браузера (Chrome).&lt;/p&gt;

&lt;video autoplay=&quot;&quot; loop=&quot;&quot; muted=&quot;&quot; playsinline=&quot;&quot; poster=&quot;http://res.cloudinary.com/ireaderinokun/image/upload/v1488961489/demo-chrome_cuswu1.jpg&quot; width=&quot;780&quot;&gt;  
    &lt;source type=&quot;video/webm&quot; src=&quot;http://res.cloudinary.com/ireaderinokun/image/upload/v1488961489/demo-chrome_cuswu1.webm&quot; /&gt;
    &lt;img src=&quot;http://res.cloudinary.com/ireaderinokun/image/upload/v1488961489/demo-chrome_cuswu1.jpg&quot; /&gt;
&lt;/video&gt;

&lt;p&gt;При помощи расширения легко применить таблицу стилей к любой странице. Вот как я это сделала.&lt;/p&gt;

&lt;h3 id=&quot;chrome-&quot;&gt;Объявление расширения Chrome: Манифест&lt;/h3&gt;

&lt;p&gt;Первое, что нам нужно сделать, при создании расширения для Chrome — создать манифест-файл. Работает это так же как в случае когда мы создаем манифест-файл для прогрессивного веб приложения (PWA прим. переводчика). Файл включает в себя различную информацию, по которой Chrome определяет, что должно делать расширение и какие разрешения ему для этого необходимы.&lt;/p&gt;

&lt;p&gt;Это файл &lt;code class=&quot;highlighter-rouge&quot;&gt;manifest.json&lt;/code&gt; для Alix —&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;manifest_version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Alix for Chrome&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;short_name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Alix&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Lorem ipsum&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;permissions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;activeTab&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;browser_action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Toggle Alix&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_popup&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;popup/index.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;default_icon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;19&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;images/toolbar-chrome.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;38&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;images/toolbar-chrome@2x.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;icons&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;128&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;icon_128.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;16&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;icon_16.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;48&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;icon_48.png&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;web_accessible_resources&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-en_advice.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-en_error.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-en_obsolete.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-en_warning.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-fr_advice.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-fr_error.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-fr_obsolete.css&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a11y.css/a11y-fr_warning.css&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Давайте разберемся, что обозначают некоторые опции —&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manifest_version&lt;/code&gt;:   версия формата файла манифеста, требуемого расширением. Для Chrome 18 требуется версия 2.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;permissions&lt;/code&gt;: разрешения, которые запрашивает ваше расширение. Alix требует только доступ к той вкладке, которая активна в данный момент.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;browser_action&lt;/code&gt; помещает иконку на главную панель Chrome и определяет действие при клике по значку.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default_title&lt;/code&gt;: тайтл для значка на панели
&lt;code class=&quot;highlighter-rouge&quot;&gt;default_popup&lt;/code&gt;: html страница, которая отобразится при клике на значок.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;web_accessible_resources&lt;/code&gt;:  массив путей к ресурсам, которые могут использоваться на странице.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Создание всплывающего окна&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://bitsofco.de/content/images/2017/03/Screen-Shot-2017-03-08-at-09.32.02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Всплывающее окно это просто html страница, указанная в манифест-файле в &lt;code class=&quot;highlighter-rouge&quot;&gt;browser_action/default_popup&lt;/code&gt;. Эта страница, по умолчанию, будет запускаться при клике на значок.&lt;/p&gt;

&lt;p&gt;С этой страницей мы можем делать все, что захотим, как с обычной html страницей.&lt;/p&gt;

&lt;h2 id=&quot;a11ycss&quot;&gt;Добавляем таблицу стилей a11y.css&lt;/h2&gt;

&lt;p&gt;Наконец, нам нужно применить к текущей активной вкладке таблицу стилей &lt;code class=&quot;highlighter-rouge&quot;&gt;a11y.css&lt;/code&gt;. Для этого должен быть запущен скрипт, который создаст на странице элемент &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;stylsheet&quot;&amp;gt;&lt;/code&gt; указывающий на необходимую таблицу стилей.&lt;/p&gt;

&lt;p&gt;Для выполнения скрипта мы воспользуемся методом &lt;code class=&quot;highlighter-rouge&quot;&gt;chrome.tabs.executeScript()&lt;/code&gt;. ​Этот метод принимает объект с несколькими параметрами. В нашем случае параметром выступит константа со строкой, содержащей код, который мы хотим выполнить.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function addStylesheet() {

    // Get file path based on language and level options from form
    const file = `/a11y.css/a11y-${options.language}_${options.level}.css`;

    const code = `
        var stylesheet = document.createElement(&quot;link&quot;);
        stylesheet.rel = &quot;stylesheet&quot;;
        stylesheet.href = chrome.extension.getURL(&quot;${file}&quot;);
        stylesheet.id = &quot;a11yCSS&quot;;
        document.getElementsByTagName(&quot;head&quot;)[0].appendChild(stylesheet);
    `;

    // Execute script on active tab
    chrome.tabs.executeScript({code: code});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Если мы откроем инспектор элементов, то увидим, что таблица стилей добавлена как последний элемент в секции head.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://bitsofco.de/content/images/2017/03/Screen-Shot-2017-03-08-at-09.35.23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;То что нужно! Как всегда, вы можете посмотреть &lt;a href=&quot;https://github.com/ireade/alix&quot;&gt;исходный код&lt;/a&gt; или установить расширение из &lt;a href=&quot;https://chrome.google.com/webstore/detail/alix-for-chrome/aepmadgjacfjcneccddiccnkbpimobge&quot;&gt;магазина Chrome&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Спасибо &lt;a href=&quot;https://twitter.com/ffoodd_fr&quot;&gt;Gaël Poupard&lt;/a&gt; за созданный им &lt;a href=&quot;http://ffoodd.github.io/a11y.css/&quot;&gt;a11y.css&lt;/a&gt;!&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Mar 2017 00:00:00 +0400</pubDate>
        <link>http://front-end.su/making-alix-a-chrome-extension-for-linting-html</link>
        <guid isPermaLink="true">http://front-end.su/making-alix-a-chrome-extension-for-linting-html</guid>
      </item>
    
      <item>
        <title>Линтинг HTML с помощью CSS</title>
        <description>&lt;p&gt;&lt;i&gt;Данный материал является вольным переводом статьи: &lt;br /&gt;Ire Aderinokun &lt;a href=&quot;https://bitsofco.de/linting-html-using-css/&quot;&gt;Linting HTML using CSS&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Когда HTML написан не правильно, то ничего особенного не происходит. Однако, в таком случае на сайте могут появиться блоки, которые не семантичны или недоступны для пользователя.&lt;/p&gt;

&lt;p&gt;Существует множество способов проверки HTML для обнаружения и устранения проблем. К примеру, можно воспользоваться &lt;a href=&quot;https://validator.w3.org/&quot;&gt;валидатором W3C&lt;/a&gt;. Но есть еще одна вещь которую мы с легкостью можем интегрировать в процесс разработки — использовать некоторые усовершенствованные CSS селекторы для выделения потенциально проблемных областей. Ниже мы рассмотрим несколько примеров, которые помогут нам в этом.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Встроенные стили&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
*[style] { 
  border: 5px solid red; /* Стиль для выделения элементов */
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Этот селектор применится к элементам страницы, в которых используются встроенные (инлайновые) стили. Их использования стоит избегать, так как инлайновые стили трудно переопределить из-за повышенного уровня специфичности. Хотя есть случаи, когда встроенные стили необходимы, но они тоже будут выделены нашим селектором. Поэтому решение о необходимости использования инлайновых стилей принимается в каждом конкретном случае.&lt;/p&gt;

&lt;p&gt;Выбрав проблемные элементы, мы можем применить к ним оформление, чтобы сделать их заметными на странице, например, добавить красную рамку.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;Неисправные или отсутствующие ссылки&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
a:not([href])  
a[href=&quot;#&quot;],  
a[href=&quot;&quot;],  
a[href*=&quot;javascript:void(0)&quot;] { … }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Эти селекторы выделяют ссылки, которые либо не содержат атрибута &lt;code class=&quot;highlighter-rouge&quot;&gt;href&lt;/code&gt;, либо он не несет смысла.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;Недоступные изображения&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
img:not([alt]) { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Как правило, &lt;a href=&quot;https://bitsofco.de/alternative-text-and-images/&quot;&gt;изображения должны иметь атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;alt&lt;/code&gt;&lt;/a&gt;. Когда же он отсутствует, большинство скринридеров считывает вместо него значение атрибута &lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;, которое бесполезно для пользователя и может ввести его в заблуждение.&lt;/p&gt;

&lt;p&gt;Описанный селектор не будет выбирать изображения с пустым атрибутом, т.е.изображения с &lt;code class=&quot;highlighter-rouge&quot;&gt;alt=&quot;&quot;&lt;/code&gt;. Это связано с тем, что пустой атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;alt&lt;/code&gt; может быть преднамеренным способом пропустить считывание скринридером, что полезно, например, если изображение используется в декоративных целях. Тем не менее было бы полезно, если бы такие теги выделялись. Сделать это мы можем следующим селектором —&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;img[alt=&quot;&quot;] { ... }&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;Отсутствие языка документа&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
html:not([lang]),
html[lang=&quot;&quot;] { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Важным атрибутом, который должен присутствовать во всех элементах &lt;code class=&quot;highlighter-rouge&quot;&gt;html&lt;/code&gt; является атрибут языка. Этот атрибут помогает определить скринридерам язык страницы.&lt;/p&gt;

&lt;p&gt;Вот пример того, что произойдет, если  будет отсутствовать атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;lang&lt;/code&gt;&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;ru&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Share &lt;a href=&quot;https://twitter.com/HTeuMeuLeu&quot;&gt;@HTeuMeuLeu&lt;/a&gt;&amp;#39;s video to show why setting a default language (eg. lang=&amp;quot;en&amp;quot;) is important. 😂 &lt;a href=&quot;https://t.co/tjn8GvPVKM&quot;&gt;https://t.co/tjn8GvPVKM&lt;/a&gt;&lt;/p&gt;&amp;mdash; overflow: heydon (@heydonworks) &lt;a href=&quot;https://twitter.com/heydonworks/status/834714116715663361&quot;&gt;23 февраля 2017 г.&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;section-4&quot;&gt;Неправильная кодировка&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
meta[charset]:not([charset=&quot;UTF-8&quot;]) { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Этот селектор предназначен для мета-тега, кодировка которого установлена не в &lt;code class=&quot;highlighter-rouge&quot;&gt;UTF-8&lt;/code&gt;. Этот тег говорит браузеру о том, что нужно использовать кодировку &lt;code class=&quot;highlighter-rouge&quot;&gt;UTF-8&lt;/code&gt;, которая в настоящее время является рекомендуемой для html документов.&lt;/p&gt;

&lt;p&gt;Использование этого тега &lt;a href=&quot;http://validator.w3.org/docs/help.html#faq-charset&quot;&gt;необходимо для валидного html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;В идеале, этот тег должен идти первым, после открывающего &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;. Мы можем проверить это, используя следующий селектор —&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
meta[charset=&quot;UTF-8&quot;]:not(:first-child) { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;viewport&quot;&gt;Недопустимые атрибуты Viewport&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
meta[name=&quot;viewport&quot;][content*=&quot;user-scalable=no&quot;],
meta[name=&quot;viewport&quot;][content*=&quot;maximum-scale&quot;],
meta[name=&quot;viewport&quot;][content*=&quot;minimum-scale&quot;] { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Этот селектор необходимо использовать для выделения недопустимых значений viewport. Как правило, рекомендуется избегать ограничения возможности пользователю манипулировать областью просмотра, масштабируя ее.  Таким образом выражения &lt;code class=&quot;highlighter-rouge&quot;&gt;user-scalable=no&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;maximum-scale&lt;/code&gt; или &lt;code class=&quot;highlighter-rouge&quot;&gt;minimum-scale&lt;/code&gt; никогда не должны использоваться.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;Немаркированные элементы формы&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
input:not([id]),  
select:not([id]),  
textarea:not([id]) { ... }

label:not([for]) { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Элементы формы, пожалуй, являются самыми важными тегами, когда дело доходит до маркировки. Хотя и существует &lt;a href=&quot;https://bitsofco.de/labelling-form-elements/&quot;&gt;несколько способов маркировки&lt;/a&gt;, наиболее распространенным способом является использование id, на который ссылается label. Данный селектор проверяет элементы форм, которые не имеют id и элементы label, которые не связаны явно с элементом формы при помощи атрибута &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Другой тип маркировки, который важен для элементов формы — это атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;. Хотя атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; используется для маркировки элемента в контексте документа. Атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; используется в качестве ссылки на элемент при отправке данных формой.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
input:not([name]),
select:not([name]),
textarea:not([name]) { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Кроме того, помимо самих элементов формы, полезно присваивать тегу формы имя и/или идентификатор.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
`form:not([name]):not([id]) { ...` }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Этот селектор выделяет теги form, у которых отсутствуют оба атрибута — &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;Пустые интерактивные элементы&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
button:empty,
a:empty { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Интерактивные элементы, такие как ссылки или кнопки, обычно размечаются их контентом. Хотя эти элементы можно размечать с помощью других методов, таких как атрибут &lt;code class=&quot;highlighter-rouge&quot;&gt;aria-label&lt;/code&gt;, ситуация, когда теги не содержат контента, скорее всего признак чего-то неправильного. Этот селектор выделяет любые ссылки и кнопки без содержимого.&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;Необязательные или устаревшие атрибуты&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;css&quot;&gt;
script[type=&quot;text/javascript&quot;],
link[rel=&quot;stylesheet&quot;][type=&quot;text/css&quot;] { ... }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Наконец, мы можем использовать селектор, чтобы выделить элементы с атрибутами которые устарели или не являются обязательными.&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Mar 2017 00:00:00 +0400</pubDate>
        <link>http://front-end.su/linting-html-using-css</link>
        <guid isPermaLink="true">http://front-end.su/linting-html-using-css</guid>
      </item>
    
      <item>
        <title>Почему нет никакого CSS4? Разбираемся с CSS Levels</title>
        <description>&lt;p&gt;&lt;i&gt;Данный материал является вольным переводом статьи: &lt;br /&gt;Rachel Andrew &lt;a href=&quot;https://www.rachelandrew.co.uk/archives/2016/09/13/why-there-is-no-css4-explaining-css-levels/&quot;&gt;Why there is no CSS4 - explaining CSS Levels&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;У нас были CSS1 и CSS2. У нас даже был CSS 2.1, который сразу перешёл в CSS3. Или это мы перешли? Этот пост — краткое объяснение того, как CSS версионируется сегодня.&lt;/p&gt;

&lt;p&gt;CSS версий 1 и 2 были монолитными спецификациями. Все, что касалось CSS было включено в один большой документ. Селекторы, позиционирование, цвета — всё было там.&lt;/p&gt;

&lt;p&gt;Проблема монолитной спецификации в том, что для того чтобы её закончить, каждый входящий в неё элемент должен быть завершён. CSS стал сложнее, добавились новые функции.
Больше нет смысла создавать черту, которая будет останавливать работу над всеми частями CSS только для того, чтобы объявить, что очередная версия закончена. Поэтому после версии 2.1 спецификация была разделена на модули. Так как модули включали в себя все то, что было раньше, плюс добавились новые возможности — все они вышли на третий уровень. Следовательно, люди вроде меня, которые понимали CSS как единую спецификацию, называют модули третьего уровня как CSS 3.&lt;/p&gt;

&lt;p&gt;Пока мы относимся ко всему новому в CSS как к CSS 3, работающему не в полную силу, это не будет отражать реальность того, где находится CSS сейчас. Если вы читали что-то о селекторах в CSS 3, то фактически описанное является частью спецификации &lt;a href=&quot;https://www.w3.org/TR/css3-selectors/&quot;&gt;CSS Selectors Level 3&lt;/a&gt;. На самом деле CSS Selectors является одной из спецификаций, отмеченных как завершенная и рекомендуемая.
В данный момент рабочая группа по CSS работает над &lt;a href=&quot;https://drafts.csswg.org/selectors-4/&quot;&gt;Selectors Level 4&lt;/a&gt; с новыми предложенными функциями, а также возможностями которые были частью третьего уровня (а также CSS 1 и 2).
Это &lt;a href=&quot;https://www.w3.org/TR/CSS/#css-level-4&quot;&gt;не CSS 4&lt;/a&gt;, но спецификация 4-го уровня единой спецификации. Одна небольшая часть.&lt;/p&gt;

&lt;p&gt;Также есть спецификации возможностей, которые никогда не были частью CSS 1 или 2 и поэтому они относятся к первому уровню. Они являются совершенно новыми. К примеру, к первому уровню относятся спецификации &lt;a href=&quot;https://drafts.csswg.org/css-grid/&quot;&gt;CSS Grid Layout&lt;/a&gt; и &lt;a href=&quot;https://www.w3.org/TR/css-flexbox-1/&quot;&gt;Flexbox&lt;/a&gt;. Flexbox и Grid находятся в статусе Candidate Recommendation (CR).Поэтому любые новые возможности, которые предлагаются в данный момент, вероятно, в итоге попадут на следующий уровень этих спецификаций – Flexbox Level 2 и CSS Grid Level 2.&lt;/p&gt;

&lt;p&gt;Если вы хотите посмотреть состояние тех или иных возможностей и их уровень,  можете сделать это в документе &lt;a href=&quot;https://www.w3.org/Style/CSS/current-work&quot;&gt;Current Work&lt;/a&gt;. Чтобы разобраться в различных статусах, советуем обратиться &lt;a href=&quot;https://www.w3.org/2005/10/Process-20051014/tr#maturity-levels&quot;&gt;к этому документу&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Sep 2016 00:00:00 +0400</pubDate>
        <link>http://front-end.su/why-there-is-no-css4</link>
        <guid isPermaLink="true">http://front-end.su/why-there-is-no-css4</guid>
      </item>
    
      <item>
        <title>Разбираемся с функциями первого класса в Sass 3.5</title>
        <description>&lt;p&gt;&lt;i&gt;Данный материал является вольным переводом статьи: &lt;br /&gt;Kaelig &lt;a href=&quot;https://medium.com/@kaelig/sass-first-class-functions-6e718e2b5eb0/&quot;&gt;Making sense out of Sass 3.5 first-class functions&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1200/1*K7bBVfi4k9a7wUci_nCg-w.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Озадачены последней &lt;a href=&quot;http://blog.sass-lang.com/posts/809572-sass-35-release-candidate&quot;&gt;записью в блоге Sass Release Candidate&lt;/a&gt;? Я тоже.&lt;/p&gt;

&lt;p&gt;Sass 3.5.0-RC.1 отмечен введением нового типа данных — «функций первого класса». &lt;a href=&quot;http://blog.sass-lang.com/posts/809572-sass-35-release-candidate&quot;&gt;В анонсе релиз-кандидата&lt;/a&gt; четыре длинных пункта, посвященных функциям первого класса, в которых упоминается тонна деталей, без каких-либо примеров кода. Я не очень понимаю, что это значит, поэтому решил глубже разобраться в данном вопросе…&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Функции первого класса&lt;/h2&gt;

&lt;p&gt;В заметке про релиз-кандидат написано следующее:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Вы можете получить функцию первого класса передав ее имя
&lt;strong&gt;get-function($name)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Это значит что &lt;strong&gt;get-function($name)&lt;/strong&gt; вернет функцию первого класса.&lt;/p&gt;

&lt;p&gt;Что такое функция первого класса?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;В информатике язык программирования имеет функции первого класса, если он рассматривает функции как объекты первого класса. – &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0&quot;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Звучит неплохо. Отлично, функции! Вы только что получили большое обновление.&lt;/p&gt;

&lt;p&gt;Затем, в записи упоминается:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;вы можете передать ее (функцию первого класса) в &lt;strong&gt;call()&lt;/strong&gt; в том же месте где вы передавали имя функции&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;В этом есть смысл, но по прежнему не хватает примеров. Я бы хотел получить ответ на вопрос: «Где и почему мы должны использовать &lt;strong&gt;get-function($name)&lt;/strong&gt;?”&lt;/p&gt;

&lt;p&gt;Давайте сначала посмотрим с чего мы начали.&lt;/p&gt;

&lt;h2 id=&quot;sass--35&quot;&gt;Вызов функции в Sass &amp;lt; 3.5&lt;/h2&gt;

&lt;p&gt;Два варианта:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. my-function($arguments)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Классический вызов функции. Никаких сюрпризов.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@function my-function() { @return ‘Hello, world.’; }
my-function(); // -&amp;gt; ‘Hello, world.’
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2. или используя call()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вы можете быть не знакомы с &lt;strong&gt;call&lt;/strong&gt; и это нормально. Большинству разработчиков этот вариант никогда не понадобится, так как по большей части он полезен для разработчиков библиотеки. Мы передаем имя функции &lt;strong&gt;call()&lt;/strong&gt;, который вызывает указанную функцию.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@function my-function() { @return ‘Hello, world.’; }
call(‘my-function’) // -&amp;gt; ‘Hello, world.’
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Важно: Sass 3.5 признает устаревшим этот вариант.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;В любых таблицах стилей, где имена функций передаются как строки,
нужно переключиться на использование функций первого класса. С этой целью, &lt;strong&gt;вызов call() со строкой признается устаревшим&lt;/strong&gt;. Это не вызовет серьезных ошибок вплоть до версии 4.0, но &lt;strong&gt;мы настоятельно рекомендуем пользователям перейти к использованию get-function() немедленно&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Примеры:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@function foo($x) { @return $x; }
foo(&#39;bar&#39;); // -&amp;gt; &#39;bar&#39;

// УСТАРЕЛО: ПЕРЕСТАНЕТ РАБОТАТЬ В Sass 4.0.0
call(&#39;foo&#39;, &#39;bar&#39;); // -&amp;gt; &#39;bar&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Давайте посмотрим как работать со вторым вариантом (&lt;strong&gt;call()&lt;/strong&gt;) в Sass 3.5.0 и выше!&lt;/p&gt;

&lt;h2 id=&quot;sass-35--&quot;&gt;Вызов функции в Sass 3.5 и выше&lt;/h2&gt;

&lt;p&gt;В Sass 3.5 функцию необходимо вызывать при помощи &lt;strong&gt;call()&lt;/strong&gt; передав функцию первого класса при помощи &lt;strong&gt;get-function&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. my-function($arguments)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Без паники, этот вариант еще работает.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. call(get-function(‘my-function’), $arguments)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Теперь вы передаете функцию первого класса, вместо строки.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@function foo($x) { @return $x; }

h1 {
  content: call(
    get-function(&#39;foo&#39;),
    &#39;It works :)&#39;
  );
}

h2 {
  content: call(
    get-function(foo),
    &#39;(even without quotes)&#39;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;call-get-function.scss&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;h1 { content: &quot;It works :)&quot;; }
h2 { content: &quot;(even without quotes)&quot;; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;output-call-get-functions.css&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. call($my-function, $arguments)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Это правда, вы можете присвоить функцию первого класса в переменную!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@​function my-function() { @​return ‘Great!’; }
$my-function: get-function(my-function); // Новое в Sass 3.5.0!
call($my-function); // -&amp;gt; Great!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@function foo($x) { @return $x; }
$foo: get-function(foo);
h1 {
  content: call($foo, &#39;bar&#39;);
} assign-function-to-variable.scss

h1 { content: &quot;bar&quot;; } output-assign-function-to-variable.css
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;К сожалению, $my-function() и $foo(‘bar’) не будут работать.
При попытке компиляции вы получите следующую ошибку:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Error: get-function(“foo”) isn’t a valid CSS value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;На первый взгляд, мне показалось хорошей идеей иметь возможность писать &lt;strong&gt;$a(b)&lt;/strong&gt; в Sass, но могут быть последствия, которые мы не учли! Давайте посмотрим, что будет в следующих версиях.&lt;/p&gt;

&lt;h2 id=&quot;sass&quot;&gt;Написание кода, совместимого со всеми версиями Sass&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*QqHJIgeZyYw-uezoAzR1AQ.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Авторы библиотек должны обновиться до call(get-function())&lt;/p&gt;

&lt;p&gt;Если вам необходимо поддерживать несколько версий, есть способы написания кода, который будет совместим с Sass 3.3 и выше.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Использование function-exists&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вы можете воспользоваться &lt;strong&gt;function-exists($name)&lt;/strong&gt;, чтобы определять доступна ли get-function (в этом случае будет передаваться функция первого класса), в противном случае будет использован старый синтаксис (передача строки):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@function foo($x) { @return $x; }

h1 {
  @if (function-exists(&#39;get-function&#39;)) {
    content: call(get-function(&#39;foo&#39;), &#39;Отобразится в Sass 3.5.0 и выше&#39;);
  } @else {
    content: call(&#39;foo&#39;, &#39;Отобразится в Sass 3.3.x и 3.4.x&#39;);
  }
}

// К сожалению, назначение функции в переменную
// не может быть полифиллом для Sass 3.3.x и 3.4.x
$foo: get-function(foo);
h1 { content: call($foo, &#39;bar&#39;); }
// -&amp;gt; el { content: get-function(foo)(&quot;bar&quot;); }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;compatibility.scss&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Использование safe-get-function&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Я создал утилиту под названием &lt;strong&gt;safe-get-function&lt;/strong&gt; которая работает и со старыми и с новыми версиями Sass, так что вы можете начать использовать get-function прямо сейчас и быть готовым к выходу версий 3.5 и 4.0&lt;/p&gt;

&lt;p&gt;safe-get-function() доступна в npm:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install sass-safe-get-function
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ссылка на GitHub:
&lt;a href=&quot;https://github.com/kaelig/sass-safe-get-function&quot;&gt;https://github.com/kaelig/sass-safe-get-function&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;Подведем итоги&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*xmjxJl4e89aFYBGA1V8xTQ.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Моя реакция, когда я узнал о модульной системе в Sass 4.0&lt;/p&gt;

&lt;p&gt;В предстоящем релизе версии 3.5 нет ничего революционного, но я в восторге от возможностей в контексте Sass 4.0 и новой модульной системы, где не все находится в глобальной области видимости (это мажорное изменение).&lt;/p&gt;

&lt;p&gt;Если ваша библиотека или фреймворк использует call(): сейчас самое время чтобы начать работу по совместимости с Sass 3.5 и обновить ваш код сегодня, используя &lt;strong&gt;call(safe-get-function($name))&lt;/strong&gt; вместо &lt;strong&gt;call($name)&lt;/strong&gt;:
&lt;a href=&quot;https://github.com/kaelig/sass-safe-get-function&quot;&gt;https://github.com/kaelig/sass-safe-get-function&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Если вы не разработчик Sass библиотеки: вероятно, эти изменения не повлияют на вас, но, надеюсь, эта статья сделала так, что будущие релизы Sass стали выглядеть менее ужасающими.&lt;/p&gt;

&lt;p&gt;Хотите поиграть с get-function? Я сделал песочницу в репозитории   &lt;a href=&quot;https://github.com/kaelig/sass-first-class-functions&quot;&gt;https://github.com/kaelig/sass-first-class-functions&lt;/a&gt;, развлекайтесь!&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;Источники&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.sass-lang.com/posts/809572-sass-35-release-candidate&quot;&gt;Sass 3.5.0 Release Candidate&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sass-lang.com/documentation/Sass/Script/Functions.html#call-instance_method&quot;&gt;Documentation for call()&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;First-class functions on Wikipedia&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/kaelig/sass-first-class-functions&quot;&gt;Download the playground on GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/kaelig/sass-safe-get-function&quot;&gt;safe-get-function Sass utility on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;Благодарность&lt;/h3&gt;

&lt;p&gt;Спасибо &lt;a href=&quot;https://medium.com/u/66dddc4d84eb&quot;&gt;Chris Eppstein&lt;/a&gt; за то что посмотрел и предложил использовать function-exists для обеспечения пути обновления для авторов библиотек.&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Sep 2016 00:00:00 +0400</pubDate>
        <link>http://front-end.su/sass-first-class-functions</link>
        <guid isPermaLink="true">http://front-end.su/sass-first-class-functions</guid>
      </item>
    
      <item>
        <title>Знакомство с debugger.html</title>
        <description>&lt;p&gt;&lt;i&gt;Данный материал является вольным переводом статьи: &lt;br /&gt;Bryan Clark &lt;a href=&quot;https://hacks.mozilla.org/2016/09/introducing-debugger-html/&quot;&gt;Introducing debugger.html&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;debugger.html — современный JavaScript отладчик от Mozilla, сделанный на &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; и &lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;. Проект начался в начале этого года в попытке заменить &lt;a href=&quot;https://developer.mozilla.org/en/docs/Tools&quot;&gt;Firefox Developer Tools&lt;/a&gt;. Помимо этого мы хотели сделать отладчик с возможностью отладки нескольких целей и функционирования в стандартном режиме.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2016/09/colla.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;В данный момент debugger.html можно подключить к Firefox, а так же в экспериментальном режиме связать с Chrome и Node.  Отладчик подключается при помощи Mozilla’s &lt;a href=&quot;https://wiki.mozilla.org/Remote_Debugging_Protocol&quot;&gt;Remote Debug Protocol&lt;/a&gt; (RDP) и взаимодействует с Node и Chrome используя &lt;a href=&quot;https://developer.chrome.com/devtools/docs/debugger-protocol&quot;&gt;Chrome’s RDP&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Проект debugger.html размещен на &lt;a href=&quot;https://github.com/devtools-html/debugger.html&quot;&gt;GitHub&lt;/a&gt; и использует современные фреймворки и наборы инструментов, что делает его доступным и привлекательным для широкой аудитории разработчиков.&lt;/p&gt;

&lt;h2 id=&quot;debuggerhtml&quot;&gt;debugger.html&lt;/h2&gt;
&lt;p&gt;Пользовательский интерфейс разделён на три области: панель исходников, панель редактирования и правый сайдбар.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Панель исходников&lt;/em&gt; показывает дерево всех исходников для отлаживаемого в данный момент приложения.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Панель редактирования&lt;/em&gt; используется для отображения содержимого файлов исходников, установки брейкпоинтов и улучшения форматирования исходников.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Правый сайдбар&lt;/em&gt; текущие установленные брейкпоинт, текущий вызов стека и области видимости переменных, когда отладчик находится в паузе
    &lt;ul&gt;
      &lt;li&gt;Отладчик поддерживает паузу, step over, step in, step out и запуск функций для отладки вашего JavaScript.&lt;/li&gt;
      &lt;li&gt;Панель вызова стека отображает фреймы &lt;em&gt;вызова стека&lt;/em&gt; для состояний в паузе, а &lt;em&gt;панель областей видимости&lt;/em&gt; показывает раскрываемое дерево переменных на основе выбранного фрейма.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2016/09/debug.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Приступая к работе&lt;/h2&gt;

&lt;p&gt;Прежде чем приступить к работе с отладчиком вы должны получить код с GitHub и посмотреть &lt;a href=&quot;https://github.com/devtools-html/debugger.html/blob/master/CONTRIBUTING.md#getting-started&quot;&gt;руководство к началу работы&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Если вы хотите сразу приступить к работе, выполните следующие команды:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install - установите зависимости
npm start - запустите сервер разработки
open http://localhost:8000 - откройте в любом современном браузере
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;После того как вы открыли отладчик в браузере главная страница отладчика будет отображать список целей для отладки, которые мы можете выбрать. Для того чтобы подключить отладчик и начать работу, цель должна быть запущена с возможностью удаленной отладки. Обычно это требует установки нескольких флагов. Например, если вы хотите запустить Firefox на MacOS вы должен включить отладку с помощью следующей команды.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ /Applications/Firefox.app/Contents/MacOS/firefox-bin –start-**debugger**-server 6080 -P development
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Другие опции для Chrome и Firefox вы можете найти &lt;a href=&quot;https://github.com/devtools-html/debugger.html/blob/master/docs/remotely-debuggable-browsers.md#&quot;&gt;здесь&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Отладка Node требует наличия у вас версии &lt;a href=&quot;https://nodejs.org/en/blog/release/v6.3.0/&quot;&gt;6.3.0&lt;/a&gt; или выше. Node вы должны запускать со специальным флагом. Например, если вы хотите отлаживать &lt;code class=&quot;highlighter-rouge&quot;&gt;myserver.js&lt;/code&gt; вы должны использовать следующую команду.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ node –inspect myserver.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Больше информации вы можете получить &lt;a href=&quot;https://github.com/devtools-html/debugger.html/blob/master/CONTRIBUTING.md#getting-started&quot;&gt;в руководстве к началу работы&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;firefox-developer-tools&quot;&gt;Firefox Developer Tools&lt;/h2&gt;
&lt;p&gt;Мы интегрируем отладчик в Developer Tools для Firefox. Первая итерация закончена и включена в ночную сборку. Вы можете попробовать отладчик там.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2016/09/jsfiddle.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;Примите участие&lt;/h2&gt;

&lt;p&gt;Как уже упоминалось выше, проект находится в разработке, мы будем благодарны за вашу помощь в создании, возможно, лучшего отладчика. Если вы хотите присоединиться к нам, пожалуйста, ознакомьтесь с &lt;a href=&quot;https://github.com/devtools-html/debugger.html/blob/master/CONTRIBUTING.md&quot;&gt;руководством контрибьютера&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0400</pubDate>
        <link>http://front-end.su/introducing-debugger-html</link>
        <guid isPermaLink="true">http://front-end.su/introducing-debugger-html</guid>
      </item>
    
      <item>
        <title>Первое десктопное приложение на HTML, JS и Electron</title>
        <description>&lt;p&gt;&lt;i&gt;Данный материал является вольным переводом статьи: &lt;br /&gt;Danny Markov &lt;a href=&quot;http://tutorialzine.com/2015/12/creating-your-first-desktop-app-with-html-js-and-electron/&quot;&gt;Creating Your First Desktop App With HTML, JS and Electron&lt;/a&gt;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Материал вычитывал: &lt;i&gt;Михаил Синяков&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/creating-your-first-with-electron.jpg&quot; class=&quot;main-img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Веб-приложения становятся все более мощными с каждым годом, но остается еще место для классических приложений, обладающих полным доступом к оборудованию компьютера. Сегодня вы можете создать десктопное приложения при помощи хорошо знакомых вам HTML, JS и Node.js, упаковать его в исполняемый файл и пользоваться им на Windows, OS X и Linux.&lt;/p&gt;

&lt;p&gt;Существуют два самых популярных проекта с открытым исходным кодом, позволяющих сделать это. Это &lt;a href=&quot;http://nwjs.io/&quot;&gt;NW.js&lt;/a&gt; и &lt;a href=&quot;http://electron.atom.io/&quot;&gt;Electron&lt;/a&gt;, последний мы и будем рассматривать сегодня. Мы собираемся переписать версию, &lt;a href=&quot;http://tutorialzine.com/2015/01/your-first-node-webkit-app/&quot;&gt;которую делали на NW.js&lt;/a&gt;, так что вы сможете еще и сравнить их между собой.&lt;/p&gt;

&lt;h2 id=&quot;electron&quot;&gt;Начинаем работу с Electron&lt;/h2&gt;

&lt;p&gt;Программы, которые создаются при помощи Electron это просто веб сайты, которые открываются во встроенном браузере Chromium. В дополнение к стандартным API HTML5 эти сайты могут использовать полный набор модулей Node.js и специальных модулей Electron, которые позволяют получить доступ к операционной системе.&lt;/p&gt;

&lt;p&gt;В этом уроке мы создадим простое приложение, которое получает последние статьи с сайта Tutorialzine через RSS и отображает их в виде карусели. Все исходники, вы можете &lt;a href=&quot;http://demo.tutorialzine.com/2015/12/creating-your-first-desktop-app-with-html-js-and-electron/creating-your-first-desktop-app-with-electron.zip&quot;&gt;скачать архивом по ссылке&lt;/a&gt;.
Распакуйте его содержимое в любую директорию на вашем компьютере.&lt;/p&gt;

&lt;p&gt;Глядя на структуру файлов вы никогда бы не догадались что это десктопное приложение, а не просто веб сайт.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/electron-app-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Мы рассмотрим наиболее интересные файлы и то как они работают минутой позже, а пока давайте заглянем под капот.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;Запуск приложения&lt;/h2&gt;

&lt;p&gt;Поскольку приложение Electron это просто Node.js приложение, вам нужно установить &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;. Сделать это довольно просто.&lt;/p&gt;

&lt;p&gt;Откройте терминал и выполните в директории проекта следующую команду:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Это создаст папку &lt;strong&gt;node_modules&lt;/strong&gt;, содержащую все необходимые зависимости для приложения. Затем, введите в терминале следующее:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Приложение должно открыться в новом окне, обратите внимание, что оно имеет только верхнее меню и больше ничего.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/electron_app_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Вы наверное обратили внимание,что приложение запускается не слишком удобно для пользователя. Однако это просто способ для разработчика запустить приложение. Когда оно будет упаковано, пользователь будет запускать его как обычно — двойным кликом по иконке.&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;Как это сделано&lt;/h2&gt;

&lt;p&gt;Сейчас мы поговорим о наиболее важных файлах, которые используются в любом приложении, написанном при помощи Electron. Давайте начнем с файла package.json, который содержит различную информацию о проекте. Например, версию, список npm зависимостей и другую не менее важную информацию.&lt;/p&gt;

&lt;h3 id=&quot;packagejson&quot;&gt;package.json&lt;/h3&gt;

&lt;pre&gt;
&lt;code class=&quot;json&quot;&gt;
{
  &quot;name&quot;: &quot;electron-app&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;dependencies&quot;: {
    &quot;pretty-bytes&quot;: &quot;^2.0.1&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;electron-prebuilt&quot;: &quot;^0.35.2&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;electron main.js&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Если вы уже работали с Node.js, то у вас уже имеется представление как это все работает. Важно отметить команду &lt;code class=&quot;highlighter-rouge&quot;&gt;npm start&lt;/code&gt; которая запускает приложение. Когда мы вызываем эту команду в консоли, то просим electron запустить файл &lt;strong&gt;main.js&lt;/strong&gt;. Этот файл содержит маленький скрипт, который открывает окно приложения, определяет некоторые параметры и обработчики событий.&lt;/p&gt;

&lt;h3 id=&quot;mainjs&quot;&gt;main.js&lt;/h3&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
var app = require(&#39;app&#39;);  // Модуль управления приложением.
var BrowserWindow = require(&#39;browser-window&#39;);  // Модуль для создания окна браузера.

// Сохраняем глобальную ссылку на объект Window, если этого не сделать
// окно закроется автоматически как только сработает сборщик мусора JS.
var mainWindow = null;

// Выйти, после того как все окна будут закрыты.
app.on(&#39;window-all-closed&#39;, function() {
    // В OS X это характерно для приложений и их меню,
    // чтобы оставаться активными, пока пользователь явно не завершит работу 
    // при помощи Cmd + Q
    if (process.platform != &#39;darwin&#39;) {
        app.quit();
    }
});

// Этот метод будет вызван когда Electron закончил
// инициализацию и готов к созданию окна браузера.
app.on(&#39;ready&#39;, function() {
    // Создаем окно браузера.
    mainWindow = new BrowserWindow({width: 900, height: 600});

    // и загружаем index.html в приложение.
    mainWindow.loadURL(&#39;file://&#39; + __dirname + &#39;/index.html&#39;);

    // Генерируется когда окно закрыто.
    mainWindow.on(&#39;closed&#39;, function() {
        // Сброс объекта окна, обычно нужен когда вы храните окна
        // в массиве, это нужно если в вашем приложении множество окон, 
        // в таком случае вы должны удалить соответствующий элемент.
        mainWindow = null;
    });
});
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Давайте взглянем на то, что мы делаем в методе &lt;code class=&quot;highlighter-rouge&quot;&gt;ready&lt;/code&gt;. Сначала мы определяем окно браузера и устанавливаем его первоначальный размер. Затем мы загружаем в него файл &lt;strong&gt;index.html&lt;/strong&gt;, который работает точно так же, как если бы мы открыли его в браузере.&lt;/p&gt;

&lt;p&gt;Как вы видите, в самом файле нет ничего особенного — контейнер для карусели и пункты для отображения статистики использования процессора и оперативной памяти.&lt;/p&gt;

&lt;h3 id=&quot;indexhtml&quot;&gt;index.html&lt;/h3&gt;

&lt;pre&gt;
&lt;code class=&quot;html&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;&lt;br /&gt;&amp;lt;html&amp;gt;&lt;br /&gt;&amp;lt;head&amp;gt;&lt;br /&gt;&lt;br /&gt;    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;&lt;br /&gt;    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;&lt;br /&gt;&lt;br /&gt;    &amp;lt;title&amp;gt;Tutorialzine Electron Experiment&amp;lt;/title&amp;gt;&lt;br /&gt;&lt;br /&gt;    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./css/jquery.flipster.min.css&amp;quot;&amp;gt;&lt;br /&gt;    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./css/styles.css&amp;quot;&amp;gt;&lt;br /&gt;&lt;br /&gt;&amp;lt;/head&amp;gt;&lt;br /&gt;&amp;lt;body&amp;gt;&lt;br /&gt;&lt;br /&gt;&amp;lt;div class=&amp;quot;flipster&amp;quot;&amp;gt;&lt;br /&gt;    &amp;lt;ul&amp;gt;&lt;br /&gt;    &amp;lt;/ul&amp;gt;&lt;br /&gt;&amp;lt;/div&amp;gt;&lt;br /&gt;&lt;br /&gt;&amp;lt;p class=&amp;quot;stats&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;br /&gt;&lt;br /&gt;&amp;lt;!-- Правильный способ подключить jQuery в Electron приложении --&amp;gt;&lt;br /&gt;&amp;lt;script&amp;gt;window.$ = window.jQuery = require(&amp;#39;./js/jquery.min.js&amp;#39;);&amp;lt;/script&amp;gt;&lt;br /&gt;&amp;lt;script src=&amp;quot;./js/jquery.flipster.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br /&gt;&amp;lt;script src=&amp;quot;./js/script.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br /&gt;&amp;lt;/body&amp;gt;&lt;br /&gt;&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Здесь у нас html-код, ссылки на необходимые стили, js библиотеки и скрипты. Заметили что jQuery подключен странным способом? См. этот &lt;a href=&quot;http://stackoverflow.com/questions/32621988/electron-jquery-is-not-defined&quot;&gt;issue&lt;/a&gt;, чтобы узнать почему подключение происходит именно так.&lt;/p&gt;

&lt;p&gt;Наконец, собственно сам JavaScript код нашего приложения. В нем мы подключаемся к RSS ленте, получаем последние статьи и показываем их. Если мы попытаемся провернуть такую операцию в окружении браузера, то ничего не получится. Канал находится  на другом домене и получение данных с него запрещено. Однако в Electron такого ограничения нет, мы можем получить необходимую информацию при помощи AJAX-запроса.&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;js&quot;&gt;
$(function(){

    // Отображаем информацию о компьютере используя node-модуль os.

    var os = require(&#39;os&#39;);
    var prettyBytes = require(&#39;pretty-bytes&#39;);

    $(&#39;.stats&#39;).append(&#39;Number of cpu cores: &amp;lt;span&amp;gt;&#39; + os.cpus().length + &#39;&amp;lt;/span&amp;gt;&#39;);
    $(&#39;.stats&#39;).append(&#39;Free memory: &amp;lt;span&amp;gt;&#39; + prettyBytes(os.freemem())+ &#39;&amp;lt;/span&amp;gt;&#39;);

    // Библиотека UI компонентов Electron. Понадобится нам позже.

    var shell = require(&#39;shell&#39;);


    // Получаем последние записи с Tutorialzine.

    var ul = $(&#39;.flipster ul&#39;);

    // Политики безопасности в Electron не применяются, поэтому
    // мы можем отправлять ajax-запросы на другие сайты. Обратимся к Tutorialzine

    $.get(&#39;http://feeds.feedburner.com/Tutorialzine&#39;, function(response){

        var rss = $(response);

        // Найдем все статьи в RSS потоке:

        rss.find(&#39;item&#39;).each(function(){
            var item = $(this);

            var content = item.find(&#39;encoded&#39;).html().split(&#39;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&#39;)[0]+&#39;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&#39;;
            var urlRegex = /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;amp;:/~\+#]*[\w\-\@?^=%&amp;amp;/~\+#])?/g;

            // Получим первое изображение из статьи.
            var imageSource = content.match(urlRegex)[1];


            // Создадим li для каждой статьи и добавим в неупорядоченный список.

            var li = $(&#39;&amp;lt;li&amp;gt;&amp;lt;img /&amp;gt;&amp;lt;a target=&amp;quot;_blank&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#39;);

            li.find(&#39;a&#39;)
                .attr(&#39;href&#39;, item.find(&#39;link&#39;).text())
                .text(item.find(&quot;title&quot;).text());

            li.find(&#39;img&#39;).attr(&#39;src&#39;, imageSource);

            li.appendTo(ul);

        });

        // Инициализируем плагин flipster.

        $(&#39;.flipster&#39;).flipster({
            style: &#39;carousel&#39;
        });

        // При клике на статью откроем страницу в браузере по умолчанию.
        // В противном случае откроем ее в окне Electron.

        $(&#39;.flipster&#39;).on(&#39;click&#39;, &#39;a&#39;, function (e) {

            e.preventDefault();

            // Откроем URL в браузере по умолчанию.

            shell.openExternal(e.target.href);

        });

    });

});
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Есть одна классная вещь, в приведенном выше коде, она заключается в том, что в одном файле можно одновременно использовать:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JavaScript библиотеки — jQuery и &lt;a href=&quot;https://github.com/drien/jquery-flipster&quot;&gt;jQuery Flipster&lt;/a&gt; для создания карусели.&lt;/li&gt;
  &lt;li&gt;Собственный модули Electron  — оболочку, которая предоставляет API для desktop-задач. В нашем случае открытие url в браузере по умолчанию.&lt;/li&gt;
  &lt;li&gt;Node.js модули — Модуль &lt;a href=&quot;https://nodejs.org/api/os.html&quot;&gt;OS&lt;/a&gt; для доступа к информации о системе, &lt;a href=&quot;https://www.npmjs.com/package/pretty-bytes&quot;&gt;Pretty Bytes&lt;/a&gt; для форматирования.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С их помощью наше приложение готово к работе!&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;Упаковка и дистрибуция.&lt;/h2&gt;

&lt;p&gt;Есть еще одна важная вещь, которую нужно сделать чтобы ваше приложение попало к конечному пользователю. Вы должны упаковать его в исполняемый файл, который будут запускать двойным щелчком. Необходимо будет собрать отдельный дистрибутив для каждой из систем: Windows, OS X, Linux. В этом нам поможет &lt;a href=&quot;https://github.com/maxogden/electron-packager&quot;&gt;Electron Packager&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Вы должны принять во внимание тот факт, что в упакованный файл попадут все ваши ресурсы, все зависимости node.js, а так же уменьшенная копия браузера webkit. В конечном итоге получится файл порядка 50mb. Это довольно много и не практично для простых приложений, как, например, наше, но этот вопрос становится не актуальным, когда речь идет о больших и сложных приложениях.&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;Единственное серьезное отличие от NW.js состоит в том, что в NW.js точкой входа выступает HTML-файл, в то время как в Electron эту роль выполняет JavaScript файл. C Electron вы получаете больше контроля. Вы легко можете построить мульти оконное приложение и организовать обмен данными между ними.&lt;/p&gt;

&lt;p&gt;Вот что можно еще почитать по теме:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/atom/electron/blob/master/docs/tutorial/quick-start.md&quot;&gt;Electron’s Quick Start Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/atom/electron/tree/master/docs&quot;&gt;Electron’s Documentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://electron.atom.io/#built-on-electron&quot;&gt;Apps Built with Electron&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 13 Jun 2016 00:00:00 +0400</pubDate>
        <link>http://front-end.su/2016/06/13/creating-your-first-desktop-app-with-electron/</link>
        <guid isPermaLink="true">http://front-end.su/2016/06/13/creating-your-first-desktop-app-with-electron/</guid>
      </item>
    
  </channel>
</rss>
